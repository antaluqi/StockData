%% read from postgresql
% ===============================================================================================================

clc
clear
connection=database('testDB','postgres','123456','org.postgresql.Driver','jdbc:postgresql://localhost:5432/testDB');
curs = exec(connection, 'select distinct code from aa;');
row = fetch(curs);
code_list = row.Data;

query = 'select * from information_schema.columns where table_schema=''public'' and table_name=''aa''; ';
curs = exec(connection, query);
row = fetch(curs);
colume_name=row.Data(:,4);


tic
for i=1:length(code_list)
     code = code_list{i};
     query=['select * from aa where code=''', code,''';'];
     curs = exec(connection, query);
     row = fetch(curs);
     data=row.Data;
     %cell2table([cellstr(datestr(data(:,1),'yyyy-mm-dd')),num2cell(data(:,2:end))],'VariableNames',colume_name);
     
 

     store_data=[datenum(data(:,1),'yyyy-mm-dd'),cell2mat(data(:,[2:6,8:end]))];
     stroe_code=['k',data{1,7}];
     eval([stroe_code,'=store_data;'])
     DatafileName='Data';
     if i==1
            save([DatafileName,'.mat'],stroe_code,'-v6')
        else
            save([DatafileName,'.mat'],stroe_code,'-append','-v6')
     end
     i
end
colume_name={'date', 'open', 'close', 'high', 'low', 'volume'}; 
save([DatafileName,'.mat'],'colume_name','-append','-v6')

toc
close(curs)
close(connection)


%% write to postgresql
% ===============================================================================================================
clc
clear


code='603605';
disp('载入数据....')
load('Data.mat',['k',code])
disp('数据载入完成')
eval(['d=k',code,';']);
data=[num2cell(d),cellstr(repmat(code,[size(d,1),1]))];





% 计算结果存储表名
storeTable='cc';
% 判断表是否存在
connection=database('testDB','postgres','123456','org.postgresql.Driver','jdbc:postgresql://localhost:5432/testDB');
query= ['select 1 from information_schema.tables where table_schema = ''public'' and table_name = ''',storeTable,''''];
curs = exec(connection, query);
row = fetch(curs);
% 如果表存在则删除
if row.Data{1}==1
    query=['drop table ',storeTable];
    curs = exec(connection, query);
    row = fetch(curs);
end
query='create table public.cc (date date,open real,close real,high real,low real,volume real,ma5 real,ma10 real,ma20 real,ma30 real,code text)';
curs = exec(connection, query);
row = fetch(curs);


tic


colnames={'date','open','close','high','low','volume','ma5','ma10','ma20','ma30','code'};
fastinsert(connection,storeTable,colnames,data)
toc



close(curs)
close(connection)

%% ==============================================================================================
clc
clear
connection=database('testDB','postgres','123456','org.postgresql.Driver','jdbc:postgresql://localhost:5432/testDB');
curs = exec(connection, 'select distinct code from aa;');
row = fetch(curs);
code_list = row.Data;
%% ================================================================================================
% 傅里叶滤波研判趋势
addpath([cd,'\stock']);
clear
clc
conn=database('testDB','postgres','123456','org.postgresql.Driver','jdbc:postgresql://localhost:5432/testDB');
dbds=databaseDatastore(conn,'select * from findtop(''sh600118'') where top<>0');
k=dbds.readall;
t=datenum(k.date);
c=max([k.high,-k.low].*k.top,[],2);
y=fft(c);
y(10:end)=0;
plot(t,abs(ifft(y)))
hold on
plot(t,c)
hold off
close(conn)

%% ==============================================================================
% 顶点最大尺度的探测
addpath([cd,'\stock']);
clear
clc
conn=database('testDB','postgres','123456','org.postgresql.Driver','jdbc:postgresql://localhost:5432/testDB');
dbds=databaseDatastore(conn,'select * from findtop(''sh600118'')');
k=dbds.readall;
t=k(k.top~=0,:);
c=max([t.high,-t.low].*t.top,[],2);

rL=[];
hh=[];
ll=[];
base=[];
if t.top(1)==1
    baseH=c(1);
    baseL=k.low(1);
    rL(1)=(c(1)-baseH)/baseH;
    hh(1,1)=c(1);
    hh(1,2)=baseL;
    ll(1,1)=c(2);
    ll(1,2)=baseH;
    base(1)=baseH;
    base(2)=baseL;
else
    baseH=k.high(1);
    baseL=c(1);   
    rL(1)=(c(1)-baseL)/baseL;
    ll(1,1)=c(1);
    ll(1,2)=baseH;
    hh(1,1)=c(2);
    hh(1,2)=baseL;
    base(1)=baseL;
    base(2)=baseH;
end
rL(2)=(c(2)-c(1))/c(1);

for i=3:length(c)
    if t.top(i)==1
        baseL=c(i-1);
        for j=size(hh,1):-1:1
            if c(i)>=hh(j,1)
                baseL=hh(j,2);
                hh(j,:)=[];
            else
                hh(end+1,:)=[c(i),baseL];
                rL(i)=(c(i)-baseL)/baseL;
                base(i)=baseL;
                break;
            end
        end
    else
        baseH=c(i-1);
        for j=size(ll,1):-1:1
            if c(i)<=ll(j,1)
                baseH=ll(j,2);
                ll(j,:)=[];
            else
                ll(end+1,:)=[c(i),baseH];
                rL(i)=(c(i)-baseH)/baseH;
                base(i)=baseH;
                break
            end
        end
    end
end
t.c=c;
t.rL=rL'*100;
t.base=base';
t
close(conn);








